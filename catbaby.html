<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>cat baby factory</title>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r71/three.min.js"></script>
	<script src="//js.leapmotion.com/leap-0.6.4.min.js"></script>
	<script src="//js.leapmotion.com/leap-plugins-0.1.10.min.js"></script>
	<script src="//js.leapmotion.com/leap.rigged-hand-0.1.7.min.js"></script>
	<style>
		#boxes {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			z-index: 100;
		}
		.box {
			position: absolute;
			width: 100px;
			height: 100px;
		}
		.active-cat {
			background-color: red;
		}
		.active-baby {
			background-color: blue;
		}
		.gripped {
			border: 5px dashed pink;
		}
		canvas{
			pointer-events: none;
		}
	</style>
</head>
<body>
	<div id="output"></div>
	<div id="boxes">
		<div class="box active-cat"></div>
		<div class="box active-baby"></div>	
	</div>
	
</body>

<script>
	var output = document.getElementById('output'),
		frameString = "",
		hand,
		handPositionOnScreen,
		leftBox = document.querySelectorAll('.active-cat')[0],
		rightBox = document.querySelectorAll('.active-baby')[0];

	(window.controller = new Leap.Controller)
	    .use('riggedHand')
	    .connect();

	function concatData(id, data){
		return id + ': ' + data + '<br>';
	}

	function isColliding(elem1, elem2){
		var elem1Bounds = {
							x: elem1.getBoundingClientRect().left, 
							y: elem1.getBoundingClientRect().top, 
							width: elem1.getBoundingClientRect().width,
							height: elem1.getBoundingClientRect().height
						},
			elem2Bounds = {
							x: elem2.getBoundingClientRect().left, 
							y: elem2.getBoundingClientRect().top, 
							width: elem2.getBoundingClientRect().width,
							height: elem2.getBoundingClientRect().height
						};

		if (elem1Bounds.x < elem2Bounds.x + elem2Bounds.width &&
		   elem1Bounds.x + elem1Bounds.width > elem2Bounds.x &&
		   elem1Bounds.y < elem2Bounds.y + elem2Bounds.height &&
		   elem1Bounds.height + elem1Bounds.y > elem2Bounds.y) {
		    return true;
		} else {
			return false;
		}
	}

	function makeCatBaby(elem1, elem2) {
		var catBabyFrag = document.createDocumentFragment(),
			catBabyPart1 = elem1.cloneNode(),
			catBabyPart2 = elem2.cloneNode();

		catBabyFrag.appendChild(catBabyPart1);
		catBabyFrag.appendChild(catBabyPart2);

		return catBabyElem;
	}

	controller.on('frame', function(frame){
		frameString = concatData('frame_id', frame.id);

		// hands
		for(var i = 0, len = frame.hands.length; i < len; i++) {
			hand = frame.hands[i];
			handPositionOnScreen = hand.data('riggedHand.mesh').screenPosition(hand.fingers[1].tipPosition); //{x: [int], y: [int], z: [int]}

			frameString += concatData('hand type', hand.type);
			frameString += concatData('grab strength', hand.grabStrength);

			
			switch (hand.type){
				case 'right': 
					rightBox.style.left = handPositionOnScreen.x + 'px'; 
					rightBox.style.bottom = handPositionOnScreen.y + 'px';
					rightBox.style.zIndex = Math.floor(handPositionOnScreen.z);
					hand.grabStrength > 0.7 ? rightBox.classList.add('gripped') : rightBox.classList.remove('gripped');
					break;
				case 'left':
					leftBox.style.left = handPositionOnScreen.x + 'px'; 
					leftBox.style.bottom = handPositionOnScreen.y + 'px';
					leftBox.style.zIndex = Math.floor(handPositionOnScreen.z);
					hand.grabStrength > 0.7 ? leftBox.classList.add('gripped') : leftBox.classList.remove('gripped');
					break;
			}

		}

		// console.log('collision: ' + isColliding(leftBox, rightBox));

		if(isColliding(leftBox, rightBox) === true) {

		}

		output.innerHTML = frameString;

	});

</script>

</html>